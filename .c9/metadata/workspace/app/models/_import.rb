{"changed":true,"filter":false,"title":"_import.rb","tooltip":"/app/models/_import.rb","value":"def parse_area_header_v1(header)\n  m = header.match(/\\{(.*)\\} (........) (.*)~\\s*F ([0-9|]+)/)\n  \n  header_info = Hash.new\n  \n  header_info[\"version\"] = 1\n  \n  if m\n    header_info[\"author\"] = m[2].strip\n    header_info[\"name\"]   = m[3].strip\n    header_info[\"flags\"]  = read_flags( m[4].strip )\n\n    if m[1].match(/(\\d) (\\d)/)\n      range = m[1].match(/(\\d+) (\\d+)/)\n        header_info[\"range_low\"]  = range[1].to_i\n        header_info[\"range_high\"] = range[2].to_i\n    else\n      if m[1].match(/ALL/)\n        header_info[\"range_low\"]   = 1\n        header_info[\"range_high\"]  = 50\n      end\n      if m[1].match(/HARD/)\n        header_info[\"range_low\"]   = 50\n        header_info[\"range_high\"]  = 50\n      end\n    end\n  end\n\n  return header_info\n  \nend\n\ndef parse_area_header_v2(header)\n  header_info = Hash.new\n  \n  header_info[\"version\"] = 2\n  \n  header_info[\"author\"] = header.match(/Author (.*)~/)[1].strip\n  header_info[\"name\"]   = header.match(/Name (.*)~/)[1].strip\n  header_info[\"flags\"]  = header.match(/Flags (.*) End/)[1].strip\n  \n  header_info[\"range_low\"]   = header.match(/Lowlevel (\\d.*)\\n/)[1].to_i\n  header_info[\"range_high\"]  = header.match(/Highlevel (\\d.*)\\n/)[1].to_i\n  \n  header_info[\"description\"]  = header.match(/Description\\n(.*)\\n~/m)[1].strip\n  \n  if header.match(/Installed (.*)\\n/)\n    header_info[\"installed\"]  = header.match(/Installed (.*)\\n/)[1].strip\n  else\n    header_info[\"installed\"]  = nil\n  end\n  \n  return header_info\n  \nend\n\ndef parse_mobiles(mobiles_block)\n  mobiles_info = Hash.new\n  i = 1\n  \n  mobiles = mobiles_block.split(\"#\").map(&:strip)\n  \n  mobiles.each do |mobile|\n    m = mobile.match(/^(\\d*)\\n(.*)~\\n(.*)~\\n(.*)\\n~\\n/)\n    mobile_info = Hash.new\n    mobile_info[\"vnum\"]     = m[1].to_i\n    mobile_info[\"keywords\"] = m[2].strip\n    mobile_info[\"sdesc\"]    = m[3].strip\n    mobile_info[\"ldesc\"]    = m[4].strip\n    \n    m = mobile.match(/^~\\n(.*)\\n~\\n([0-9|]*) ([0-9|]*) ([-\\d]*) S\\n(\\d*).*\\n8 8 (\\d*)/m)\n    mobile_info[\"look_desc\"]    = m[1].strip\n    mobile_info[\"act_flags\"]    = read_flags( m[2].strip )\n    mobile_info[\"affect_flags\"] = read_flags( m[3].strip )\n    mobile_info[\"alignment\"]    = m[4].to_i\n    mobile_info[\"level\"]        = m[5].to_i\n    mobile_info[\"sex\"]          = m[6].to_i\n    \n    # add all the optionals!!! L, A, N, O\n    if mobile.match(/^L\\n(\\d*) (\\d*)/)\n      languages = mobile.match(/^L\\n(\\d*) (\\d*)/)\n      mobile_info[\"langs_known\"] = languages[1].to_i\n      mobile_info[\"lang_spoken\"] = languages[2].to_i\n    end\n    \n    # Should we even check this since it's in the act_flags?\n    if mobile.match(/^A$/)\n      mobile_info[\"animal\"] = true\n    end\n    \n    # Should we even check this since it's in the act_flags?\n    if mobile.match(/^N$/)\n      mobile_info[\"no_wear_eq\"] = true\n    end\n    \n    if mobile.match(/^O\\n(.*)~/)\n      mobile_info[\"one_spell\"] = mobile.match(/^O\\n(.*)~/)[1].strip\n    end\n    \n    mobiles_info[i] = mobile_info\n    i = i + 1\n  end\n  \n  return mobiles_info\nend\n\ndef parse_objects(objects_block)\n  objects_info = Hash.new\n  i = 1\n  \n  objects = objects_block.split(\"#\").map(&:strip)\n  \n  objects.each do |object|\n    m = object.match(/^(\\d*)\\n(.*)~\\n(.*)~\\n(.*)\\n~\\n/)\n    object_info = Hash.new\n    object_info[\"vnum\"]     = m[1].to_i\n    object_info[\"keywords\"] = m[2].strip\n    object_info[\"sdesc\"]    = m[3].strip\n    object_info[\"ldesc\"]    = m[4].strip\n    \n    m = object.match(/^(\\d*) ([0-9|]*) ([0-9|]*)\\n(\\d*) ([0-9|]*) (\\d*) (\\d*)\\n(\\d*) (\\d*) 0/)\n    object_info[\"object_type\"] = m[1].to_i\n    object_info[\"extra_flags\"] = read_flags( m[2].strip )\n    object_info[\"wear_flags\"]  = read_flags( m[3].strip )\n    object_info[\"v0\"]          = m[4].to_i\n    object_info[\"v1\"]          = read_flags( m[5].strip )\n    object_info[\"v2\"]          = m[6].to_i\n    object_info[\"v3\"]          = m[7].to_i\n    object_info[\"weight\"]      = m[8].to_i\n    object_info[\"cost\"]        = m[9].to_i\n\n    if object.match(/^E$/) # any extra descriptions?\n      object_info[\"extra_descs\"] = parse_extra_descs( object.split(/^E$/).map(&:strip) )\n    end\n    \n    if object.match(/^A$/) # Object has any applies?\n      applies_list = object.split(/^A$/).map(&:strip) # Split by A and remove front end junk.\n      applies_list.shift\n      \n      applies = Hash.new\n      \n      j = 1\n      \n      applies_list.each do |apply_group|\n        \n        apply = Hash.new\n        am = apply_group.match(/^(\\d*) (\\d*)/)\n        apply[\"apply_type\"] = am[1].to_i\n        apply[\"amount\"]     = am[2].to_i\n        \n        applies[j] = apply\n        j = j + 1\n      end\n      \n      object_info[\"applies\"] = applies\n    end\n    \n    if object.match(/^F$/)\n      object_info[\"flammable\"] = true\n    end\n    if object.match(/^M$/)\n      object_info[\"metallic\"] = true\n    end\n    if object.match(/^T$/)\n      object_info[\"two_handed\"] = true\n    end\n    if object.match(/^U$/)\n      object_info[\"underwater_breath\"] = true\n    end\n    \n    objects_info[i] = object_info\n    i = i + 1\n  end\n  \n  return objects_info\nend\n\ndef parse_extra_descs(extras_list)\n  extras_list.shift\n  extra_descs = Hash.new\n  \n  i = 1\n  \n  extras_list.each do |desc|\n    m = desc.match(/^(.*)~\\n(.*)\\n~/m)\n\n    if m\n      extra_desc = Hash.new\n      extra_desc[\"keywords\"]    = m[1].strip\n      extra_desc[\"description\"] = m[2].strip\n\n      extra_descs[i] = extra_desc\n      i = i + 1\n    end\n  end  \n  \n  return extra_descs\n  \nend\n\ndef read_flags( flags )\n  \n  if flags.match(/|/)\n\n    total = 0\n    number_list = flags.split(\"|\").map(&:strip)\n    number_list.each do |number|\n      total = total + number.to_i\n    end\n    \n    return total\n  else\n    return flags.to_i\n  end\n\nend\n\ndef parse_rooms(rooms_block)\n  rooms_info = Hash.new\n  i = 1\n  \n  rooms = rooms_block.split(\"#\").map(&:strip)\n  \n  rooms.each do |room|\n    m = room.match(/^(\\d+)\\n(.*)~\\n([^~]*)\\n~\\n(\\d*) ([0-9|]*) (\\d*)/)\n    room_info = Hash.new\n    room_info[\"vnum\"]        = m[1].to_i\n    room_info[\"name\"]        = m[2].strip\n    room_info[\"description\"] = m[3].strip\n    room_info[\"area_number\"] = m[4].to_i\n    room_info[\"room_flags\"]  = read_flags( m[5].strip )\n    room_info[\"terrain\"]     = m[6].to_i\n    \n    if room.match(/^E$/) # any extra descriptions?\n      room_info[\"extra_descs\"] = parse_extra_descs( room.split(/^E$/).map(&:strip) )\n    end\n    \n    if room.match(/^D\\d$/) # any exits?\n      #room_info[\"exits\"] = parse_exits( room.split(/^D$/).map(&:strip) )\n      \n      room_info[\"exits\"] = parse_exits( room.match(/^D\\d\\n[^#]*^S$/)[0] ) # Parse from 1st exit to end-of-room\n    end\n    \n    rooms_info[i] = room_info\n    i = i + 1\n  end\n  \n  return rooms_info\nend\n\ndef parse_exits(exits_block)\n  exits_block.gsub!(/^D(\\d)$/,'Exit: \\1')\n  exits_block.gsub!(/^E\\n^.*~\\n[^~]*~/, '') # remove extra descriptions\n  exits_block.gsub!(/^S$/, '') # remove trailing S\n  \n  exits_list = exits_block.split(/^Exit: /).map(&:strip)\n  exits_list.shift\n  \n  exits_info = Hash.new\n  i = 1\n  \n  exits_list.each do |exit_data|\n    exit_info = Hash.new\n    \n    m = exit_data.match(/^(\\d)$/)\n    exit_info[\"direction\"]   = m[1].to_i\n    \n    m = exit_data.match(/\\d\\n([^~]*)~/)\n    exit_info[\"description\"] = m[1].strip\n  \n    m = exit_data.match(/^(.*)~\\n(\\d*) (\\d*) (\\d*)$/)\n    exit_info[\"keywords\"]    = ( m[1].strip == nil ? \"\" : m[1].strip )\n    exit_info[\"exittype\"]    = m[2].to_i\n    exit_info[\"key_vnum\"]    = m[3].to_i\n    exit_info[\"exit_vnum\"]   = m[4].to_i\n    \n    if exit_data.match(/^O$/)\n      m = exit_data.match(/^O\\n(.*)~/)\n      exit_info[\"name\"] = m[1].strip\n    end\n    \n    exits_info[i] = exit_info\n    i = i + 1\n  end\n  \n  return exits_info\nend","undoManager":{"mark":-2,"position":2,"stack":[[{"start":{"row":215,"column":3},"end":{"row":216,"column":0},"action":"insert","lines":["",""],"id":666}],[{"start":{"row":216,"column":0},"end":{"row":217,"column":0},"action":"insert","lines":["",""],"id":667}],[{"start":{"row":217,"column":0},"end":{"row":286,"column":3},"action":"insert","lines":["def parse_rooms(rooms_block)","  rooms_info = Hash.new","  i = 1","  ","  rooms = rooms_block.split(\"#\").map(&:strip)","  ","  rooms.each do |room|","    m = room.match(/^(\\d+)\\n(.*)~\\n([^~]*)\\n~\\n(\\d*) ([0-9|]*) (\\d*)/)","    room_info = Hash.new","    room_info[\"vnum\"]        = m[1].to_i","    room_info[\"name\"]        = m[2].strip","    room_info[\"description\"] = m[3].strip","    room_info[\"area_number\"] = m[4].to_i","    room_info[\"room_flags\"]  = read_flags( m[5].strip )","    room_info[\"terrain\"]     = m[6].to_i","    ","    if room.match(/^E$/) # any extra descriptions?","      room_info[\"extra_descs\"] = parse_extra_descs( room.split(/^E$/).map(&:strip) )","    end","    ","    if room.match(/^D\\d$/) # any exits?","      #room_info[\"exits\"] = parse_exits( room.split(/^D$/).map(&:strip) )","      ","      room_info[\"exits\"] = parse_exits( room.match(/^D\\d\\n[^#]*^S$/)[0] ) # Parse from 1st exit to end-of-room","    end","    ","    rooms_info[i] = room_info","    i = i + 1","  end","  ","  return rooms_info","end","","def parse_exits(exits_block)","  exits_block.gsub!(/^D(\\d)$/,'Exit: \\1')","  exits_block.gsub!(/^E\\n^.*~\\n[^~]*~/, '') # remove extra descriptions","  exits_block.gsub!(/^S$/, '') # remove trailing S","  ","  exits_list = exits_block.split(/^Exit: /).map(&:strip)","  exits_list.shift","  ","  exits_info = Hash.new","  i = 1","  ","  exits_list.each do |exit_data|","    exit_info = Hash.new","    ","    m = exit_data.match(/^(\\d)$/)","    exit_info[\"direction\"]   = m[1].to_i","    ","    m = exit_data.match(/\\d\\n([^~]*)~/)","    exit_info[\"description\"] = m[1].strip","  ","    m = exit_data.match(/^(.*)~\\n(\\d*) (\\d*) (\\d*)$/)","    exit_info[\"keywords\"]    = ( m[1].strip == nil ? \"\" : m[1].strip )","    exit_info[\"exittype\"]    = m[2].to_i","    exit_info[\"key_vnum\"]    = m[3].to_i","    exit_info[\"exit_vnum\"]   = m[4].to_i","    ","    if exit_data.match(/^O$/)","      m = exit_data.match(/^O\\n(.*)~/)","      exit_info[\"name\"] = m[1].strip","    end","    ","    exits_info[i] = exit_info","    i = i + 1","  end","  ","  return exits_info","end"],"id":668}]]},"ace":{"folds":[],"scrolltop":3710,"scrollleft":0,"selection":{"start":{"row":286,"column":3},"end":{"row":286,"column":3},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":264,"state":"start","mode":"ace/mode/ruby"}},"timestamp":1460848369147}